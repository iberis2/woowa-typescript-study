# [ğŸ”— 1ì£¼ì°¨: (1~4ì¥) ê°ì²´ íƒ€ì…, íƒ€ì… í™•ì¥, íƒ€ì… ì¢íˆê¸°](https://velog.io/@iberis/14ì¥-ê°ì²´-íƒ€ì…-íƒ€ì…-í™•ì¥-íƒ€ì…-ì¢íˆê¸°)

> ## ğŸ’¡ìš©ì–´ ì •ë¦¬
**í´ë¦¬í•„** : ë¸Œë¼ìš°ì €ê°€ ì§€ì›í•˜ì§€ ì•ŠëŠ” ì½”ë“œë¥¼ ë¸Œë¼ìš°ì €ê°€ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì½”ë“œë¡œ ë³€í™˜í•œ ì½”ë“œ ì¡°ê°ì´ë‚˜ í”ŒëŸ¬ê·¸ì¸
**ìŠˆí¼ì…‹** : ê¸°ì¡´ ì–¸ì–´ì— ìƒˆë¡œìš´ ê¸°ëŠ¥ê³¼ ë¬¸ë²•ì„ ì¶”ê°€í•´ì„œ ë³´ì™„í•˜ê±°ë‚˜ í–¥ìƒí•˜ëŠ” ê²ƒì„ ë§í•œë‹¤. ìŠˆí¼ì…‹ ì–¸ì–´ëŠ” ê¸°ì¡´ ì–¸ì–´ì™€ í˜¸í™˜ë˜ë©° ì¼ë°˜ì ìœ¼ë¡œ ì»´í”¼ì¼ëŸ¬ ë“±ìœ¼ë¡œ ê¸°ì¡´ ì–¸ì–´ ì½”ë“œë¡œ ë³€í™˜ë˜ì–´ ì‹¤í–‰ëœë‹¤.
**íŠ¸ëœìŠ¤íŒŒì¼** : ìµœì‹  ë²„ì „ì˜ ì½”ë“œë¥¼ êµ¬ ë²„ì „ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ê³¼ì •
**ì»´íŒŒì¼** : ì‚¬ëŒì´ ì´í•´í•˜ëŠ” ì–¸ì–´ë¥¼ ì»´í“¨í„°ê°€ ì´í•´í•  ìˆ˜ ìˆëŠ” ì–¸ì–´ë¡œ ë³€í™˜í•´ì£¼ëŠ” ê³¼ì •ìœ¼ë¡œ, ì„œë¡œ ë‹¤ë¥¸ ìˆ˜ì¤€(ê³ ìˆ˜ì¤€-ì €ìˆ˜ì¤€) ê°„ì˜ ì½”ë“œ ë³€í™˜ì„ ì˜ë¯¸
- íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì˜ ì»´íŒŒì¼ ê²°ê³¼ë¬¼ íŒŒì¼ì€ ìë°”ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ì´ë‹¤.
**ì»´íŒŒì¼ íƒ€ì…** : ì»´í“¨í„°ê°€ ì†ŒìŠ¤ì½”ë“œë¥¼ ì´í•´í•  ìˆ˜ ìˆë„ë¡ ê¸°ê³„ì–´ë¡œ ë³€í™˜ë˜ëŠ” ì‹œì 
**ëŸ°íƒ€ì„** : ì»´íŒŒì¼ í›„ ë³€í™˜ëœ íŒŒì¼ì´ ë©”ëª¨ë¦¬ì— ì ì¬ë˜ì–´ ì‹¤í–‰ë˜ëŠ” ì‹œì 
**ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜** : ì‚¬ìš©ìì™€ ìƒí˜¸ì‘ìš©í•˜ëŠ” ìŒë°©í–¥ ì†Œí†µì˜ ì›¹ì‚¬ì´íŠ¸ 
- cf) ì›¹ì‚¬ì´íŠ¸ : ë‹¨ë°©í–¥ ì ìœ¼ë¡œ ì •ë³´ë¥¼ ì œê³µí•˜ëŠ” HTML ì— ë§í¬ê°€ ì—°ê²°ëœ ì›¹ í˜ì´ì§€ ëª¨ìŒ
>
|  | **ëª…ëª©ì  íƒ€ì´í•‘** | **êµ¬ì¡°ì  íƒ€ì´í•‘** | **ë•íƒ€ì´í•‘** |
| --- | --- | --- | --- |
| íŠ¹ì§• | ëª…ì‹œì ì¸ ì´ë¦„ì„ ê°€ì§€ê³  íƒ€ì…ì„ êµ¬ë¶„í•˜ëŠ” ë°©ì‹ |  ì–´ë–¤ íƒ€ì…ì— ë¶€í•©í•˜ëŠ” ë³€ìˆ˜ì™€ ë©”ì„œë“œë¥¼ ê°€ì§ˆ ê²½ìš° í•´ë‹¹ íƒ€ì…ì— ì†í•˜ëŠ” ê²ƒìœ¼ë¡œ ê°„ì£¼í•˜ëŠ” ë°©ì‹ |  |
| íƒ€ì… ê²€ì‚¬ ì‹œì  | ì»´íŒŒì¼ íƒ€ì„ | ì»´íŒŒì¼ íƒ€ì„ | ëŸ°íƒ€ì„ |
| ì–¸ì–´ | C++, ìë°” | íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ | ìë°”ìŠ¤í¬ë¦½íŠ¸ |
| ì½”ë“œ |  |  |  |
>
```java
// ëª…ëª©ì  íƒ€ì´í•‘
class Cat {
  String name;
    public void hit(){}
}
>
class Arrow {
	String name;
	  public void hit(){}
}
>
class  Main {
    public static void main(){
        Arrow cat = new Cat(); // ğŸš¨ error : incompatible types: Cat cannot be converted to Arrow
        Cat arrow = new Arrow(); // ğŸš¨ error : incompatible types: Arrow cannot be converted to Cat
    }
}
```
>
```tsx
// êµ¬ì¡°ì  íƒ€ì´í•‘
class Cat {
	name: string;
    constructor(name: string){
        this.name = name
    }
	public hit(): void{};
}
>
class Arrow {
	name: string;
    constructor(name: string){
        this.name = name
    }
	public hit(): void{};
}
>
const cat: Arrow = new Cat('mewoo');
```
>
<details>
  <summary><h3>êµ¬ì¡°ì  íƒ€ì´í•‘(ë•íƒ€ì´í•‘)ìœ¼ë¡œ ì¸í•´ ë§ˆì£¼í•˜ëŠ” ì´ìŠˆ</h3></summary>
>
ê°ì²´ì˜ key ë¥¼ `Object.keys()` ì™€ `.map()` ë§¤ì„œë“œë¡œ ìˆœíšŒí•˜ë ¤ê³  í•  ë•Œ, key ê°€ ê°ì²´ì˜ key ë¡œ íƒ€ì…ì´ ì¢í˜€ì§€ì§€ ì•Šê³ , string ìœ¼ë¡œ ì •ì˜ë˜ëŠ” ì´ìŠˆê°€ ìˆë‹¤.
>
## [](https://5kdk.github.io/blog/2024/04/04/index-signatures-and-duck-typing#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-%EB%A7%88%EC%A3%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%8A%88)
>
```tsx
const student = {
    name: 'ì–‘í•´ìˆ˜',
    age: 21
}
>
Object.keys(student).map(key => {
  const value = student[key]; // ğŸš¨ Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ name: string; age: number; }'.  No index signature with a parameter of type 'string' was found on type '{ name: string; age: number; }'.
  return value;
});
```
>
```tsx
const studentKeyType = Object.keys(student); // string[]
```
>
ìœ„ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ë°©ë²•
1. **Obejct.keys(ê°ì²´)**ë¥¼Â `as`ë¡œ íƒ€ì… ë‹¨ì–¸    
    ```tsx
    type Student = typeof student;
>    
    (Object.keys(student) as Array<keyof Student>).map(key => {
      const value = student[key];
      return value;
    });
    ```
>    
2. ì œë„¤ë¦­ì„ í™œìš©í•´Â **Object.keys**ì— ëŒ€í•œ **ë°˜í™˜ íƒ€ì…ì„ ê°ì²´ì˜ key íƒ€ì…ìœ¼ë¡œ ê°•ì œí•˜ëŠ” í•¨ìˆ˜ë¥¼ ë§ì”Œì›€**
    - **keysOf**Â í•¨ìˆ˜ëŠ” ê°ì²´ì˜ í‚¤ë¥¼ ê°€ì§€ê³  ì˜¤ë©´ì„œ ë™ì‹œì— ê°€ì ¸ì˜¨ ë°°ì—´ì— ëŒ€í•´ì„œë„ ë§ˆì°¬ê°€ì§€ë¡œ íƒ€ì… ë‹¨ì–¸ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ê³¼ì •ì„ ê±°ì¹œë‹¤.
>    
    ```tsx
    // Object.keysë¥¼ ëŒ€ì‹ í•  keyOf í•¨ìˆ˜ ìƒì„±
    function keysOf<T extends Object>(obj: T): Array<keyof T> {
      return Array.from(Object.keys(obj)) as Array<keyof T>;
    }
>    
    keysOf(student).map(key => {
      const value = student[key];
      return value;
    });
    ```
>    
3. ìˆœíšŒí•  **key ì˜ íƒ€ì…ì„ asë¡œ ë‹¨ì–¸** 
>    
    ```tsx
    type Student = typeof student;
>    
    Object.keys(student).map(key => {
      const value = student[key as keyof Student];    
      return value;
    });  
    ```
</details>

## ê°ì²´ íƒ€ì…ì¼ê¹Œ? { }, object

### `{}` : null ê³¼ undefined ë¥¼ ì œì™¸í•œ ëª¨ë“  íƒ€ì…ì— í•´ë‹¹í•œë‹¤.

- ëŒ€ì…ì€ ê°€ëŠ¥í•˜ì§€ë§Œ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.

```tsx
const str : {} = 'ë¬¸ìì—´';
const num : {} = 123;
const bool : {} = true;
const arr: {} = [1, 2, 3];
const func: {} = () => {};
const obj: {} = {name: 'ì´ë¦„'};

const nu: {} = null; // ğŸš¨ Type 'null' is not assignable to type '{}'.
const unde: {} = undefined; // ğŸš¨ Type 'undefined' is not assignable to type '{}'.

// ì‹¤ì œ ì‚¬ìš©í•˜ë ¤ê³  í•˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.
arr[0]; // ğŸš¨ Element implicitly has an 'any' type because expression of type '0' can't be used to index type '{}'.  Property '0' does not exist on type '{}'.
func(); // ğŸš¨ This expression is not callable.  Type '{}' has no call signatures.
obj.name; // ğŸš¨ Property 'name' does not exist on type '{}'.
```

- {} íƒ€ì…ì— null ê³¼ undefined ë¥¼ í•©ì¹˜ë©´ unknown ê³¼ ë¹„ìŠ·í•´ì§„ë‹¤.

```tsx
const unkn : unknown = 'string';
if(unkn){
  unkn // const unkn: {}
} else {
  unkn // const unkn: unknown
}
```

- ë¹ˆ ê°ì²´ íƒ€ì…ì„ ì§€ì •í•˜ê¸° ìœ„í•´ì„œëŠ” ìœ í‹¸ë¦¬í‹° íƒ€ì…ìœ¼ë¡œ `Record<string, never>` ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë°”ëŒì§í•˜ë‹¤.

### `object` : ì›ì‹œíƒ€ì…ì„ ì œì™¸í•œ ê°ì²´, ë°°ì—´, ì •ê·œ í‘œí˜„ì‹, í•¨ìˆ˜, í´ë˜ìŠ¤ ë“±ê³¼ í˜¸í™˜ëœë‹¤.

ëŒ€ì…ì€ ê°€ëŠ¥í•˜ì§€ë§Œ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.

```tsx
// ì›ì‹œíƒ€ì…ì— í˜¸í™˜ë˜ì§€ ì•ŠëŠ”ë‹¤.
const str : object = 'ë¬¸ìì—´'; // ğŸš¨ Type 'string' is not assignable to type 'object'.
const num : object = 123; // ğŸš¨ Type 'number' is not assignable to type 'object'.
const bool : object = true; // ğŸš¨ Type 'boolean' is not assignable to type 'object'.
const nu: object = null; // ğŸš¨ Type 'null' is not assignable to type 'object'.
const unde: object = undefined; // ğŸš¨ Type 'undefined' is not assignable to type 'object'.

const arr: object = [1, 2, 3];
const func: object = () => {};
const obj: object = {name: 'ì´ë¦„'};

// ì‹¤ì œ ì‚¬ìš©í•˜ë ¤ê³  í•˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.
obj.name; // ğŸš¨ Property 'name' does not exist on type 'object'.
arr[0]; // ğŸš¨ Element implicitly has an 'any' type because expression of type '0' can't be used to index type '{}'.  Property '0' does not exist on type '{}'.
func(); // ğŸš¨ This expression is not callable.  Type '{}' has no call signatures.
```

---

## `type` alias ì™€ `interface`

### ê³µí†µì 

### ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ : ê°ì²´ì˜ key íƒ€ì…ì—ëŠ” ì˜¤ë¡œì§€  `string`,Â `number`,Â `symbol` íƒ€ì…ë§Œ ì§€ì •í•  ìˆ˜ ìˆë‹¤.

- literal type, ì œë„¤ë¦­ ë“±ì€ ì§€ì •í•  ìˆ˜ ì—†ë‹¤.

> **ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜(Index Signatures)** : íŠ¹ì • íƒ€ì…ì˜ ì†ì„± ì´ë¦„ì€ ì•Œ ìˆ˜ ì—†ì§€ë§Œ ì†ì„±ê°’ì˜ íƒ€ì…ì„ ì•Œê³  ìˆì„ ë•Œ ì‚¬ìš©í•˜ëŠ” ë¬¸ë²• `[key: íƒ€ì…]: íƒ€ì…` 
**ë¦¬í„°ëŸ´ íƒ€ì…(literal type)** : string, number, boolean íƒ€ì… í•˜ìœ„ì˜ êµ¬ì²´ì ì¸ íƒ€ì…
> 

```tsx
interface IStringArray { [index: number]: string; };

const A_Symbol: unique symbol = Symbol('A-type');

interface ISymbol { [A_Symbol]: number; };
type SymbolType = { [A_Symbol]: number; };

// interface ì—ì„œë„ ê°™ì€ ì—ëŸ¬ ë°œìƒ
type LiteralTypeKey = {
    [key: 'a' | 'b']: string; // ğŸš¨ An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead.
}

// Ok
type LiteralTypeKey = {
  a: string;
  b: strin;
}

```

- ë§ˆì°¬ê°€ì§€ë¡œ ê°ì²´ì˜ key íƒ€ì…ìœ¼ë¡œ í…œí”Œë¦¿ ë¦¬í„°ëŸ´ íƒ€ì…ì„ ì§ì ‘ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.
    - í…œí”Œë¦¿ ë¦¬í„°ëŸ´ íƒ€ì…ì„ íƒ€ì…ì— ì§€ì • í›„  ë§µë“œ íƒ€ì…(Mapped Type) ì •ì˜í•˜ì—¬ ì‚¬ìš©í•˜ì—¬ì•¼ í•œë‹¤.

```tsx
type AorB = 'A' | 'B';
type TempLiter = `${AorB}-type`;

//Ok
type Example = {
  [key in TempLiter]: number;
};

// Error 1
type Wrong1 = {
  `${AorB}-type`: number; // ğŸš¨ 'AorB' only refers to a type, but is being used as a value here.
}

// Error 2 computed property name ì—ëŠ” í‘œí˜„ì‹ ë˜ëŠ” symbol íƒ€ì…ë§Œ ê°€ëŠ¥í•˜ë‹¤.
type Wrong2 = {
  [`${AorB}-type`]: number; // ğŸš¨ A computed property name in a type literal must refer to an expression whose type is a literal type or a 'unique symbol' type.
}
interface IWrong2 {
  [`${AorB}-type`]: number; // ğŸš¨ A computed property name in a type literal must refer to an expression whose type is a literal type or a 'unique symbol' type.
}

// Error 3 'TempLiter' ë¼ëŠ” ë¬¸ìì—´ í‚¤ë¡œ í•´ì„ëœë‹¤.
type WrongKey = {
 TempLiter: number;
}

const wrong: WrongKey = {
  TempLiter: 123,
  ["A-type"]: 456 // ğŸš¨ Object literal may only specify known properties, and '["A-type"]' does not exist in type 'WrongKey'.
}
```

### ì°¨ì´ì 

### 1. Mapped Types ( computed property name)

 type alias ì€ **computed property name** ì„ ì‚¬ìš©í•œ íƒ€ì… ì„ ì–¸ì´ ê°€ëŠ¥í•˜ì§€ë§Œ interface ì—ì„œëŠ” ë¶ˆê°€ëŠ¥í•˜ë‹¤.

> **computed property name** : í‘œí˜„ì‹(expression)ì„ ì´ìš©í•´ ê°ì²´ì˜ key ê°’ì„ ì •ì˜í•˜ëŠ” ë¬¸ë²•
  - `[key: T]` ëŒ€ê´„í˜¸(`[]`) ì•ˆì— ë™ì ìœ¼ë¡œ ì´ë¦„ì„ ì •ì˜í•˜ëŠ” ë°©ì‹
> 

```tsx
type fruite = 'apple' | 'banana' | 'grape';

type fruitePrice = {[key in fruite]: number};

interface IFruitePrice {
	[key in fruite]: number; // ğŸš¨ A mapped type may not declare properties or methods.
}
```

```tsx
type Mapped = {
  num: number;
  str: string;
  bool: boolean;
}

type MappedType = {
  [K in keyof Mapped]: string;
}
 
interface IMapped {
  [K in keyof Mapped]: string; // ğŸš¨ Member '[K in keyof' implicitly has an 'any' type.
} // ğŸš¨ 'Mapped' only refers to a type, but is being used as a value here.
// ğŸš¨ 'string' only refers to a type, but is being used as a value here.

/* interface ë‚´ì˜ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ì—ì„œëŠ” keyof Mapped ë¥¼ í•˜ë‚˜ì˜ íƒ€ì…ìœ¼ë¡œ ì¸ì‹í•˜ì§€ ëª»í•œë‹¤
* type MappedKeys = keyof Mapped
* interface IMapped {[K in MappedKeys]: string; } // ğŸš¨ A mapped type may not declare properties or methods.
*/
```

### 2. interfaceì˜ ê²½ìš° ë™ì¼í•œ ì´ë¦„ìœ¼ë¡œ ë‹¤ì‹œ interfaceë¥¼ ì •ì˜í•´ í™•ì¥í•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•˜ì§€ë§Œ typeì€ ë™ì¼í•œ ì´ë¦„ìœ¼ë¡œ ë‹¤ì‹œ ì„ ì–¸í•  ìˆ˜ ì—†ë‹¤.

- ë‹¨ interface ê°„ì˜ ì†ì„±ì´ ê²¹ì¹˜ëŠ”ë° íƒ€ì…ì´ ë‹¤ë¥¼ ê²½ìš°ì—ëŠ” ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤
- ì¸í„°í˜ì´ìŠ¤ ê°„ì˜ ì´ë¦„ì´ ê²¹ì³ì„œ ì˜ë„í•˜ì§€ ì•Šê²Œ ë³‘í•©ë˜ê±°ë‚˜ ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ í•˜ê¸° ìœ„í•´ì„œ **namespace**  ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```tsx
interface Person {
  name: string;
};

interface Person {
  age: number;
}

const person: Person = {
  name: 'ê¹€ì§€ìˆ˜',
  age: 20
}

// ğŸš¨ Subsequent property declarations must have the same type.  Property 'age' must be of type 'number', but here has type 'string'
interface Person {
  age: string;
}
```

```tsx
type Student = {
  name: string
}

type Studnet = {
  score: number
}

const studnet: Student = { // type Student = { name: string; }
  name: 'ì´ìˆ˜ë¯¼',
  score: 100 // ğŸš¨ Object literal may only specify known properties, and 'score' does not exist in type 'Student'.
}
```

### extends : ì„œë¸Œ íƒ€ì…ì— ìŠˆí¼ íƒ€ì…ê³¼ ê°™ì€ ì†ì„± ì´ë¦„ì´ ìˆìœ¼ë©´ í•´ë‹¹ ì†ì„±ì„ ë®ì–´ì”Œìš´ë‹¤.

- ìŠˆí¼ íƒ€ì…ì˜ ì†ì„±ê°’ íƒ€ì…ë³´ë‹¤ ì„œë¸Œíƒ€ì… ì†ì„±ê°’ íƒ€ì…ì˜ ë²”ìœ„ê°€ ê°™ê±°ë‚˜ ì‘ì•„ì•¼ ë®ì–´ì”Œìš¸ ìˆ˜ ìˆë‹¤.

```tsx
interface IPerson {
  phone: string | number;
};

interface IStudent extends IPerson {
  phone: number;
}

const student:IStudent = {
  phone: 123456 // IStudent.phone: number
}

/* ì„œë¸Œ íƒ€ì…ì˜ ì†ì„± íƒ€ì…ì´ ë” ë„“ì€ ê²½ìš° íƒ€ì… ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.
ğŸš¨ Interface 'IPerson2' incorrectly extends interface 'IStudent'.
  Types of property 'phone' are incompatible.
    Type 'string | number' is not assignable to type 'number'.
      Type 'string' is not assignable to type 'number'.
*/
interface IPerson2 extends IStudent {
  phone: number | string;
}
```

- ë‹¤ ì¤‘ ìƒì†

ì—¬ëŸ¬ ê°œì˜ ìŠˆí¼ íƒ€ì…ì„ í™•ì¥í•˜ë ¤ëŠ” ê²½ìš°, ìŠˆí¼ íƒ€ì… ê°„ì˜ ì†ì„±ì´ ë™ì¼í•´ì•¼ ë‹¤ ì¤‘ ìƒì†ì´ ê°€ëŠ¥í•˜ë‹¤.
ìŠˆí¼ íƒ€ì… ê°„ì—ëŠ” ì†ì„±ì˜ íƒ€ì…ì´ ì¢í˜€ì§€ì§€ ì•ŠëŠ”ë‹¤.

```tsx
interface IPerson {
  phone: string | number;
};

interface IStudent {
  phone: number;
}

interface Phone extends IStudent, IPerson {} 
/* ğŸš¨ Interface 'Phone' cannot simultaneously extend types 'IPerson' and 'IStudent'.
     Named property 'phone' of types 'IPerson' and 'IStudent' are not identical. */
     
/*
{ phone: number } ë¡œ ì¢í˜€ì§ˆ ê²ƒ ê°™ì§€ë§Œ, ì¢í˜€ì§€ì§€ ì•Šê³  ì—ëŸ¬ ë°œìƒ
*/
```

### `&` intersection

ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ì—°ì‚°ì— ì‚¬ìš©ëœ ë‘ íƒ€ì…ì„ ëª¨ë‘ í¬í•¨í•œë‹¤. (êµì§‘í•©)
intersection typeì˜ ê²½ìš° ë¬´ì¡°ê±´ ìƒì†ì´ ì„±ê³µí•˜ê³  ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì „ì²´ íƒ€ì… ê²€ì‚¬ë¥¼ í•´ì•¼ ì´ë¥¼ ì•Œì•„ë‚¼ ìˆ˜ ìˆë‹¤.
ë”°ë¼ì„œ ë‘ íƒ€ì…ì„ intersection í•  ë•ŒëŠ” ë‘ íƒ€ì…ì˜Â **ì†ì„± ê°’ì´ êµì§‘í•©ì„ ê°€ì§€ëŠ”ì§€ ì£¼ì˜í•˜ë©° ì‚¬ìš©**í•´ì•¼í•œë‹¤.

```tsx
type PersonType = {
  phone: string;
}

type StudentType = PersonType & {
  phone: number;
}

// string íƒ€ì…ì´ë©´ì„œ number íƒ€ì…ì€ ì—†ìœ¼ë¯€ë¡œ phone ì€ never íƒ€ì…ì´ ëœë‹¤.
const student : StudentType = {
    // phone: '123456' // Type 'string' is not assignable to type 'never'.
    phone: 123456 // Type 'number' is not assignable to type 'never'. (property) phone: never
}
```

---

ì°¸ê³  
ìš°ì•„í•œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ 1 ~ 4ì¥
íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ êµê³¼ì„œ
[[TypeScript] ì—¬ëŸ¬ íƒ€ì… ì„ ì–¸ ë°©ë²•ê³¼ interface & type Alias ë¹„êµ](https://velog.io/@skawnkk/interface-type-Alias)
[[TypeScript] ì¸í„°í˜ì´ìŠ¤: í™•ì¥ê³¼ êµì°¨](https://velog.io/@violetwhenisawu/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%86%8D%EC%84%B1-6wc1ad68)
[íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì˜ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ì™€ Object.keys ê·¸ë¦¬ê³  ë• íƒ€ì´í•‘](https://5kdk.github.io/blog/2024/04/04/index-signatures-and-duck-typing)

---


> ### ğŸ’¡ ë°°ì—´ì˜ ìš”ì†Œ íƒ€ì… ì¡°íšŒ : ì¸ë±ìŠ¤ë“œ ì—‘ì„¸ìŠ¤ íƒ€ì…(Indexed Access Types)
>
- ì±… 102 í˜ì´ì§€ ì˜¤ë¥˜ : ì œë„¤ë¦­ ìœ„ì¹˜ì— íƒ€ì…ì´ ì•„ë‹Œ ê°’ì„ ì‚¬ìš© í•¨
- T ê°€ ë°°ì—´ íƒ€ì…ì´ì–´ì•¼ T[number] ê°€ ì„±ë¦½í•  ìˆ˜ ìˆìŒ
>
> `infer` í‚¤ì›Œë“œëŠ” íƒ€ì… ì¶”ë¡ ì— ì‚¬ìš©ë˜ë©°, ì¡°ê±´ë¶€ íƒ€ì… ë‚´ì—ì„œ íƒ€ì…ì„ ì¶”ë¡ í•˜ëŠ” ë³€ìˆ˜ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤.
>
```tsx
// ìˆ˜ì • 1
type ElementOf<T extends readonly any[]> = T[number];
>
const studentList = [{name: 'ê¹€ì§€ìˆ˜', class: 2}, {name: 'ì´í˜„ë¹ˆ', class: 1}];
type Student = ElementOf<typeof studentList>; // type Student = {name: string; class: number};
```
>
```tsx
// ìˆ˜ì •2
type ElementOf<T> = T extends readonly (infer U)[] ? U : never;
>
const studentList = [{name: 'ê¹€ì§€ìˆ˜', class: 2}, {name: 'ì´í˜„ë¹ˆ', class: 1}];
type Student = ElementOf<typeof studentList>; // type Student = {name: string; class: number}; 
```

## Object.prototype.toString.call(â€¦)

`Object.prototype.toString.call()`ì€ ìë°”ìŠ¤í¬ë¦½íŠ¸ ê°ì²´ì˜ ë‚´ë¶€ `[[Class]]` ì†ì„±ì„ ì´ìš©í•˜ì—¬ ê°ì²´ì˜ ì›í˜• íƒ€ì…ì„ ì •í™•í•˜ê²Œ ë°˜í™˜í•œë‹¤. ë°˜í™˜ ê°’ì˜ `[object Type]` í˜•ì‹ì—ì„œ `object`ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  ë°ì´í„°ê°€ ê°ì²´ë¼ëŠ” ê²ƒì„ ë‚˜íƒ€ë‚´ê³ , `Type`ì€ í•´ë‹¹ ê°ì²´ì˜ êµ¬ì²´ì ì¸ íƒ€ì…ì„ ë‚˜íƒ€ë‚¸ë‹¤.

```tsx
console.log(Object.prototype.toString.call({})); // [object Object]

function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}

console.log(getType([]));        // "Array"
console.log(getType({}));        // "Object"
console.log(getType(123));       // "Number"
console.log(getType(123n));       // "BigInt"
console.log(getType('abc'));     // "String"
console.log(getType(true));     // "Boolean"
console.log(getType(null));      // "Null"
console.log(getType(undefined)); // "Undefined"
console.log(getType(function() {})); // "Function"
console.log(getType(new Date())); // "Date"
console.log(getType(new Error())); // "Error"
console.log(getType(Symbol('sym'))); // "Symbol"
console.log(getType(/abc/)); // "RegExp"
```

- ë³µì¡í•œ ë‚´ë¶€ ë™ì‘ ê³¼ì •ìœ¼ë¡œ typeof ë³´ë‹¤ëŠ” ì„±ëŠ¥ ì €í•˜ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
    - ì›ì‹œ ê°’ì„ ë‹¤ë£° ë•Œ **ë°•ì‹±(ë˜í•‘) ë¹„ìš©**
    - `toString()` ë©”ì„œë“œë¥¼ ì°¾ê¸° ìœ„í•´ ê°ì²´ì˜ í”„ë¡œí† íƒ€ì… ì²´ì¸ íƒìƒ‰ ë¹„ìš©
    - íƒ€ì…ì„ `[object Type]` í˜•ì‹ì˜ ë¬¸ìì—´ë¡œ ë°˜í™˜í•˜ê¸° ìœ„í•´,  ë©”ëª¨ë¦¬ í• ë‹¹ì„ ìš”êµ¬í•˜ë©°, ë¬¸ìì—´ ì—°ì‚°ì´ í¬í•¨ëœë‹¤
    - `call()` ë©”ì„œë“œëŠ” ëª…ì‹œì ìœ¼ë¡œ `this` ê°’ì„ ì„¤ì •í•œ í›„ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ê¸° ë•Œë¬¸ì—, í•¨ìˆ˜ í˜¸ì¶œì— ëŒ€í•œ ì¶”ê°€ ë¹„ìš©ì´ ë°œìƒ

<details>
<summary><h3>ğŸ’¡ê°ì²´.toString() ìœ¼ë¡œ ë°”ë¡œ ì‚¬ìš©í•˜ì§€ ì•Šê³  `Object.prototype.toString.call(â€¦)` ì„ ì‚¬ìš©í•˜ëŠ” ì´ìœ </h3></summary>

### Object.prototype
ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ ëª¨ë“  ê°ì²´ëŠ” `Object`ì˜ ì¸ìŠ¤í„´ìŠ¤ì´ë‹¤. `Object.prototype`ì€ ëª¨ë“  ê°ì²´ì˜ ë¶€ëª¨ ê°ì²´ì´ë©°, ì—¬ê¸°ì— ì •ì˜ëœ ë©”ì„œë“œë‚˜ ì†ì„±ì€ ëª¨ë“  ê°ì²´ê°€ ìƒì†ë°›ëŠ”ë‹¤. ëª¨ë“  ê°ì²´ëŠ” `Object`ì˜ í”„ë¡œí† íƒ€ì… ì²´ì¸ì„ ë”°ë¥´ë¯€ë¡œ, ê°ì²´ì—ì„œ ë©”ì„œë“œë¥¼ ì§ì ‘ ì •ì˜í•˜ì§€ ì•Šë”ë¼ë„ `Object.prototype`ì— ì •ì˜ëœ ë©”ì„œë“œ(ex. `toString()`)ë¥¼ ìƒì†ë°›ì•„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

### .toString()

- ê°ì²´ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ëŠ” ê¸°ëŠ¥ì„ í•œë‹¤.
- ëª¨ë“  ê°ì²´ëŠ” ì´ ë©”ì„œë“œë¥¼ ìƒì†ë°›ìœ¼ë¯€ë¡œ, ê° ê°ì²´ëŠ” `toString()`ì„ í˜¸ì¶œí•˜ì—¬ ìì‹ ì„ ë¬¸ìì—´ë¡œ í‘œí˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- **ê¸°ë³¸ ë™ì‘**: ê¸°ë³¸ì ìœ¼ë¡œ `Object.prototype.toString()`ì€ ê°ì²´ì˜ íƒ€ì… ì •ë³´ë¥¼ `"[object Type]"` í˜•ì‹ìœ¼ë¡œ ë°˜í™˜í•œë‹¤. ì´ ë©”ì„œë“œëŠ” ê°ì²´ê°€ `Array`, `Function`, `Date` ë“±ì˜ êµ¬ì²´ì ì¸ íƒ€ì… ì •ë³´ë¥¼ ë°˜í™˜í•˜ë„ë¡ ì„¤ê³„ë˜ì–´ ìˆë‹¤.
- **ì˜¤ë²„ë¼ì´ë”© ê°€ëŠ¥**: ê°ì²´ê°€ ìì‹ ë§Œì˜ `toString()` ë©”ì„œë“œë¥¼ ì •ì˜í•˜ë©´, ê¸°ë³¸`Object.prototype.toString()` ëŒ€ì‹  ê°ì²´ ìì²´ì˜ ë©”ì„œë“œê°€ í˜¸ì¶œëœë‹¤.
    
 ```tsx
    const obj = {};
    console.log(obj.toString()); // [object Object] // Object.prototype.toString()ì„ í˜¸ì¶œ
    
    const arr = [];
    console.log(arr.toString()); // "" // Array.prototype.toString()ì„ í˜¸ì¶œ
 ```
    
### í•¨ìˆ˜.call(ê°ì²´)

 - ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ ëª¨ë“  í•¨ìˆ˜ì— ì •ì˜ëœ ë©”ì„œë“œë¡œ, í•¨ìˆ˜ì— íŠ¹ì •í•œ `this` ê°’ì„ ì„¤ì •í•œ ë’¤ ê·¸ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.  ì²« ë²ˆì§¸ ì¸ìˆ˜ë¡œ ì „ë‹¬ëœ ê°ì²´ë¥¼ `this`ë¡œ ì„¤ì •í•˜ê³ , ê·¸ ì´í›„ì˜ ì¸ìˆ˜ëŠ” í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜ì˜ ì¸ìˆ˜ë¡œ ì „ë‹¬ë©ë‹ˆë‹¤.
   - ì‰½ê²Œ ë§í•˜ìë©´,  ê°ì²´ì˜ ì„ì‹œ ë©”ì„œë“œë¡œ í•¨ìˆ˜ë¥¼ ë§µí•‘í•´ì¤€ë‹¤.
  - **`Object.prototype.toString.call()`ì—ì„œ `call()`ì„ ì‚¬ìš©í•˜ëŠ” ì´ìœ **ëŠ”, `toString()` ë©”ì„œë“œë¥¼ ê°ì²´ì˜ ì»¨í…ìŠ¤íŠ¸ì— ë§ê²Œ ëª…ì‹œì ìœ¼ë¡œ í˜¸ì¶œí•˜ê¸° ìœ„í•´ì„œ ì´ë‹¤. `toString()` ë©”ì„œë“œëŠ” ê°ì²´ì˜ í”„ë¡œí† íƒ€ì… ì²´ì¸ì—ì„œ ì‚¬ìš©ë  ë•Œ íŠ¹ì • ê°ì²´ì— ë°”ì¸ë”©ëœ ì±„ë¡œ í˜¸ì¶œë˜ë¯€ë¡œ, `call()`ì„ ì´ìš©í•´ `this` ê°’ì„ ê°•ì œë¡œ ë‹¤ë¥¸ ê°ì²´ë¡œ(í˜¸ì¶œí•˜ëŠ” ê°ì²´ë¡œ) ë°”ê¿”ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. 

   ```tsx
        const obj = {};
        console.log(Object.prototype.toString.call(obj)); // [object Object]
        
        const arr = [];
        console.log(Object.prototype.toString.call(arr)); // [object Array]
  ```   

  >ğŸ’¡  **`.call()`** ë©”ì„œë“œì™€ **`.apply()`** ëŠ” ì²« ë²ˆì§¸ ì¸ìë¡œ ê°ì²´ë¥¼ ë°›ì•„ì„œ ê°™ì€ ë™ì‘ì„ í•œë‹¤. call() ê³¼ì˜ ì°¨ì´ëŠ” ë‘ ë²ˆì§¸ ì¸ìë¡œ ê°’ì´ ë“¤ì–´ì˜¤ëŠ” ì§€, ë°°ì—´ì´ ë“¤ì–´ì˜¤ëŠ” ì§€ ì°¨ì´ê°€ ìˆë‹¤.
</details>
    
<details>
  <summary><h3>`Object.prototype.toString.call(ê°ì²´)` ì—ì„œ ê°ì²´ ëŒ€ì‹  ì›ì‹œíƒ€ì…ì„ ì „ë‹¬í•´ë„ ì›ì‹œíƒ€ì…ì˜ Class ê°€ ë‚˜ì˜¤ëŠ” ì´ìœ  </h3></summary>

- ìë°”ìŠ¤í¬ë¦½íŠ¸ëŠ” ì›ì‹œ íƒ€ì…ì„ ê°ì²´ì²˜ëŸ¼ ë‹¤ë£° ìˆ˜ ìˆë„ë¡ ìë™ìœ¼ë¡œ **ë˜í•‘(wrapping)**í•˜ëŠ” ê³¼ì •ì„ ê±°ì¹œë‹¤. ì´ë¥¼ **ë°•ì‹±(boxing)**ì´ë¼ê³  í•œë‹¤.
- ì›ì‹œ íƒ€ì…ì€ ê°ì²´ê°€ ì•„ë‹ˆì§€ë§Œ, ìë°”ìŠ¤í¬ë¦½íŠ¸ëŠ” ì›ì‹œ ê°’ì„ ì¼ì‹œì ìœ¼ë¡œ ê°ì²´ì²˜ëŸ¼ ë‹¤ë£° ìˆ˜ ìˆë„ë¡ **ë°•ì‹±í•œ**ë‹¤. ë”°ë¼ì„œ `Object.prototype.toString.call()` í•¨ìˆ˜ëŠ” ë°•ì‹±ëœ ê°ì²´ì˜ ë‚´ë¶€ `[[Class]]` ê°’ì„ ì‚¬ìš©í•´ í•´ë‹¹ ì›ì‹œ íƒ€ì…ì˜ ê°ì²´ ë²„ì „ì„ ë°˜í™˜í•˜ëŠ” ê²ƒì´ë‹¤.

### ë°•ì‹±(ìë™ ë˜í•‘)ì˜ ë™ì‘

ìë°”ìŠ¤í¬ë¦½íŠ¸ëŠ” ì›ì‹œ íƒ€ì…ì„ ê°ì²´ì²˜ëŸ¼ ì‚¬ìš©í•  ë•Œ, ì¼ì‹œì ìœ¼ë¡œ í•´ë‹¹ ê°’ì„ ê°ì‹¸ëŠ” ê°ì²´ë¥¼ ìƒì„±í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´, `123` ê°™ì€ ìˆ«ìëŠ” ì›ë˜ ì›ì‹œ ê°’ì´ì§€ë§Œ, ê°ì²´ì˜ ë©”ì„œë“œì²˜ëŸ¼ ë‹¤ë£° ë•Œ ìë°”ìŠ¤í¬ë¦½íŠ¸ëŠ” ìë™ìœ¼ë¡œ ìˆ«ì ì›ì‹œ ê°’ì„ `Number` ê°ì²´ë¡œ ë˜í•‘í•œë‹¤.

```tsx
const num = 123
console.log(num.toString());  // "123" (Number ê°ì²´ì˜ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•¨)
```

### `Object.prototype.toString.call(123)`ì˜ ë™ì‘

`Object.prototype.toString.call(123)`ì„ ì‹¤í–‰í•˜ë©´ ë‚´ë¶€ì ìœ¼ë¡œ ìë°”ìŠ¤í¬ë¦½íŠ¸ ì—”ì§„ì´ ìˆ«ì ì›ì‹œ ê°’ì„ `Number` ê°ì²´ë¡œ ë˜í•‘í•˜ë¯€ë¡œ ê²°ê³¼ê°’ì€ `"[object Number]"`ê°€ ëœë‹¤.

```tsx
console.log(Object.prototype.toString.call(123));  // [object Number]
```

ì´ëŠ” ì›ì‹œ ê°’ `123`ì„ **ì¼ì‹œì ìœ¼ë¡œ** `Number` ê°ì²´ë¡œ ë³€í™˜í•´ì„œ í•´ë‹¹ ê°ì²´ì˜ `[[Class]]` ì†ì„±ì„ ì°¸ì¡°í•˜ê¸° ë•Œë¬¸ì— `[object Number]`ê°€ ë°˜í™˜ëœë‹¤. 

- í•˜ì§€ë§Œ ì´ëŠ” ë°•ì‹±ëœ ê°ì²´ì¼ ë¿, ì›ì‹œ ê°’ ìì²´ê°€ ê°ì²´ë¡œ ë³€í™˜ëœ ê²ƒì€ ì•„ë‹ˆë‹¤.
</details>
---

## ì¶”ê°€ì ì¸ íƒ€ì… ê²€ì‚¬

### satisfies

- íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ 4.9 ë²„ì „ì— ì¶”ê°€ëœ ì—°ì‚°ì
- íƒ€ì… ì¶”ë¡ ì„ ê·¸ëŒ€ë¡œ í™œìš©í•˜ë©´ì„œ ì¶”ê°€ë¡œ íƒ€ì… ê²€ì‚¬ë¥¼ í•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```tsx
type Universe = {
  [key in 'sun' | 'sirius' | 'earth']: string | {type: string; parent: string};
}

// sirius ì†ì„±ì´ s`ii`rius ë¡œ ì˜¤íƒ€ê°€ ë‚¬ì„ ë•Œ,
// íƒ€ì…ìœ¼ë¡œ ë°”ë¡œ ì§€ì •í•´ì£¼ë©´ ì—ëŸ¬ëŠ” ì¡ì„ ìˆ˜ ìˆì§€ë§Œ, ë‹¤ë¥¸ íƒ€ì…ì˜ ì†ì„±ê°’ì— ì ‘ê·¼í•  ë•Œ ë¬¸ì œê°€ ìƒê¸´ë‹¤
// Problem
const universe1:Universe = {
  sun: 'star',
  siirius: 'star', // ğŸš¨ Object literal may only specify known properties, but 'siirius' does not exist in type 'Universe'. Did you mean to write 'sirius'?
  earth: {type: 'planet', parent: 'sun'}
}

// universe.earth ë„ string | {type: string; parent: string} íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ ë˜ë¯€ë¡œ earth ì˜ ì†ì„±ì— ì ‘ê·¼í•  ìˆ˜ ì—†ëŠ” ë¬¸ì œê°€ ìƒê¸´ë‹¤.
universe.earth.parent // ğŸš¨ Property 'parent' does not exist on type 'string | { type: string; parent: string; }'.  Property 'parent' does not exist on type 'string'.

// Ok
const universe2 = {
  sun: 'star',
  sirius: 'star',
  earth: {type: 'planet', parent: 'sun'}
} satisfies Universe;

/* universe2 ì˜ íƒ€ì… 
const universe: {
    sun: string;
    sirius: string;
    earth: {
        type: string;
        parent: string;
    };
}
*/
```

---

## íƒ€ì… ì¢íˆê¸°

### 1. íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ë„ ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ ë¬¸ë²•ì„ ì‚¬ìš©í•˜ë¯€ë¡œ, íƒ€ì… ì¢íˆê¸°ì— ê¼­ typeof ë¥¼ ì‚¬ìš©í•  í•„ìš”ëŠ” ì—†ë‹¤.

```tsx
/* undefined, string, null ì„ ì œëŒ€ë¡œ êµ¬ë¶„í•˜ì§€ ëª»í•œ ì˜ˆ */

function typeCheck(param: string|null|undefined){
  if(typeof param === 'undefined'){
    console.log(param, 'is undefined');
  } else if(param){ // typeof null ì€ object 
    console.log(param, 'is string');
  }else{
    console.log(param, 'is string or null');
  }
}

/* ìë°”ìŠ¤í¬ë¦½íŠ¸ ë¬¸ë²•ì„ í™œìš©í•´ì„œ êµ¬ë¶„í•œ ì˜ˆ */
function typeCheck(param: string|null|undefined){
  if(param === undefined){
    console.log(param, 'is undefined');
  } else if(param === null){
    console.log(param, 'is string');
  }else{
    console.log(param, 'is string');
  }
}
```

### 2. íƒ€ì… ì¢íˆê¸°ëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œë„ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” ì½”ë“œì—¬ì•¼ í•œë‹¤.

```tsx
interface X {
  x: number;
}

interface Y {
 y: number;
}

// Error1. if ë¬¸ì€ ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì‹¤í–‰ë˜ëŠ” ì½”ë“œì¸ë°, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•´ì„œ íƒ€ì…ì„ ì¢íˆë ¤ê³  í•˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.
function XorY(param: X | Y){
  if(param instanceof X){ // ğŸš¨ 'X' only refers to a type, but is being used as a value here.
    return param // (parameter) param: X | Y
  }
}

// Error2. ì•„ì§ íƒ€ì… ì¢íˆê¸°ê°€ ì´ë£¨ì–´ì§€ê¸° ì „ ì†ì„±ì— ì ‘ê·¼í•˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤
function XorY2(param: X | Y){
  if(param.x){ // ğŸš¨ Property 'x' does not exist on type 'X | Y'.  Property 'x' does not exist on type 'Y'.
  	 return param // (parameter) param: X | Y
  }
}

// Ok
function XorY3(param: X | Y){
  if('x' in param){ 
    return param // (parameter) param: X 
  }
}
```
  
---
ì°¸ê³ 
 [íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ êµê³¼ì„œ](https://product.kyobobook.co.kr/detail/S000208416779?utm_source=google&utm_medium=cpc&utm_campaign=googleSearch&gad_source=1&gclid=Cj0KCQjw3bm3BhDJARIsAKnHoVVvEm8AqscCY-aLy0EgZIFvKy0gml4t-osNfNr-2qC3shany_VtVlEaAo1aEALw_wcB)